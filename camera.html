<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Blank Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            cursor: none;
        }

        canvas {
            display: block;
            background-color: black;
        }
    </style>
</head>

<body oncontextmenu="return false;">
    <canvas id="canvas"></canvas>
    <script src="code/loop.js"></script>
    <script src="code/basic.js"></script>
    <script src="code/ecs.js"></script>
    <script src="code/camera.js"></script>
    <script src="code/input.js"></script>
    <script>
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");

        window.addEventListener("resize", resizeCanvas, false);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scene.camera.width = canvas.width;
            scene.camera.height = canvas.height;
        }

        window.addEventListener("visibilitychange", function () {
            if (loop.isRunning()) {
                loop.stop();
            }
            else {
                loop.start();
            }
        });

        window.addEventListener("keypress", doKeyDown, false);

        function doKeyDown(e) {
            if (e.keyCode == 47) {
                for (var i = 0; i < scene.entities.length; i++) {
                    scene.entities[i].motion.acceleration.rotate(Random.float(0, Math.PI * 2));
                }
            }
            if (e.keyCode == 46) {
                if (!scene.entityToFollow)
                    scene.entityToFollow = 0;
                scene.entities[scene.entityToFollow].getComponent("Shape").highlight = false;
                scene.entityToFollow = scene.entityToFollow >= scene.entities.length - 1 ? 0 : scene.entityToFollow + 1;
                scene.entities[scene.entityToFollow].getComponent("Shape").highlight = true;
                scene.camera.targetPosition = scene.entities[scene.entityToFollow].transform.position;
            }
        }

        class Scene {
            constructor() {
                this.width = 5000;
                this.height = 2400;
                this.entities = [];
                this.entityToFollow = null;
                this.movementSystem = new MovementSystem(this.width, this.height);
                this.camera = new Camera(canvas.width, canvas.height);
                this.shapeRendererSystem = new ShapeRendererSystem();
                this.traceRendererSystem = new TraceRendererSystem();
                this.input = new Input();
                this.runUpdate = true;
            }

            update(delta) {
                if (Input.instance.isKeyDown("NumpadMultiply"))
                    this.entityToFollow = null;

                if (this.runUpdate) {
                    this.movementSystem.update(delta, this.entities);
                    this.traceRendererSystem.update(delta, this.entities);
                }

                this.camera.update(delta);

                if (Input.instance.isKeyDown("Space"))
                    this.runUpdate = !this.runUpdate;
            }

            draw(interp) {
                // Clear canvas and save 
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();

                // Zoom camera according to scale
                ctx.scale(this.camera.zoom, this.camera.zoom);

                // Center world in canvas
                ctx.translate(canvas.width / (2 * this.camera.zoom), canvas.height / (2 * this.camera.zoom));

                // Scroll camera center
                ctx.translate(-1 * this.camera.position.x, -1 * this.camera.position.y);


                /*
                // Reference points
                for (var i = this.width / -2; i < this.width / 2; i += 20) {
                    ctx.beginPath();
                    ctx.strokeStyle = i == 0 ? Color.fixedStyle(0, 100, 50, 0.5) : Color.fixedStyle(0, 0, 100, 0.2);
                    ctx.lineWidth = 1;
                    ctx.moveTo(i, this.height / -2);
                    ctx.lineTo(i, this.height / 2);
                    ctx.stroke();
                }
                for (var i = this.height / -2; i < this.height / 2; i += 20) {
                    ctx.beginPath();
                    ctx.strokeStyle = i == 0 ? Color.fixedStyle(0, 100, 50, 0.5) : Color.fixedStyle(0, 0, 100, 0.2);
                    ctx.lineWidth = 1;
                    ctx.moveTo(this.width / -2, i);
                    ctx.lineTo(this.width / 2, i);
                    ctx.stroke();
                }
                */

                // World edges
                ctx.beginPath();
                ctx.strokeStyle = Color.fixedStyle(0, 0, 100, 1);
                ctx.lineWidth = 4;
                ctx.rect(0 - Math.round(this.width / 2), 0 - Math.round(this.height / 2), this.width, this.height);
                ctx.stroke();

                this.shapeRendererSystem.draw(interp, ctx, this.entities);
                this.traceRendererSystem.draw(interp, ctx, this.entities);

                // Restore to draw relative to window edges
                ctx.restore();

                // FPS
                ctx.fillStyle = Color.fixedStyle(0, 0, 100, 0.5);
                ctx.font = "12px monospace";
                ctx.textBaseline = "top";
                ctx.textAlign = "right";
                ctx.fillText(Math.round(loop.getFPS()) + " FPS", canvas.width - 20, 20);

                debug(ctx, scene.camera.toString(), 15, 15);

                drawCursor(ctx);
            }
        }

        function update(delta) {
            scene.update(delta);
        }

        function draw(interp) {
            scene.draw(interp);
        }

        var scene = new Scene();
        var loop = new Loop().setUpdate(update).setDraw(draw).start();
        resizeCanvas();

        // Random entities
        for (var i = 0; i < 50; i++) {
            var entity = new Entity();
            var position = new Vector(Random.float(-100, 100), Random.float(-100, 100));
            entity.addComponent(new TransformComponent(position));
            var velocity = new Vector(Random.float(-0.1, 0.1), Random.float(-0.1, 0.1));
            var maxVelocity = Random.float(0.05, 0.5);
            var acceleration = new Vector(Random.float(-0.0001, 0.0001), Random.float(-0.0001, 0.0001));
            entity.addComponent(new MotionComponent(velocity, maxVelocity, acceleration));
            var color = Color.fixedStyle(Random.value([0, 60, 100, 250]), 100, 60, 1);
            entity.addComponent(new ShapeComponent(6, 6, color));
            entity.addComponent(new TraceComponent(2, color));
            scene.entities.push(entity);
        }

        function debug(ctx, text, x, y, baseline = "top", align = "left") {
            ctx.fillStyle = Color.fixedStyle(0, 0, 100, 0.5);
            ctx.font = "12px monospace";
            ctx.textBaseline = baseline;
            ctx.textAlign = align;
            var lines = text.split("\n");
            for (var i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], x, y);
                y += 15;
            }
        }

        function drawCursor(ctx) {
            var cursor = Input.Instance.mousePosition;
            var w = 12;
            ctx.fillStyle = Color.fixedStyle(0, 0, 100, 0.8);
            ctx.beginPath();
            ctx.moveTo(cursor.x, cursor.y);
            ctx.lineTo(cursor.x + w, cursor.y + w);
            ctx.lineTo(cursor.x, cursor.y + w * 1.4142);
            ctx.closePath();
            ctx.fill();
        }

    </script>
</body>

</html>