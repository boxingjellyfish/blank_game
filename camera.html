<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Blank Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            background-color: black;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script src="code/loop.js"></script>
    <script src="code/basic.js"></script>
    <script src="code/ecs.js"></script>
    <script>
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");

        window.addEventListener("resize", resizeCanvas, false);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();

        window.addEventListener("keypress", doKeyDown, false);

        function doKeyDown(e) {
            if (e.keyCode == 43)
                entityToFollow++;
            if (e.keyCode == 45)
                entityToFollow--;
        }

        class Scene {
            constructor() {
                this.width = 5000;
                this.height = 5000;
                this.entities = [];
                this.cameraCenter = Vector.Zero;
                this.cameraScale = 0.1;
                this.movementSystem = new MovementSystem(this.width, this.height);
            }
        }

        function update(delta) {
            scene.movementSystem.update(delta, scene.entities);
        }

        var paths = [];
        var maxPaths = 1000;
        var entityToFollow = 0;

        function draw(interp) {

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // Zoom camera according to scale
            ctx.scale(scene.cameraScale, scene.cameraScale);
            // Center world in canvas
            ctx.translate(canvas.width / (2 * scene.cameraScale), canvas.height / (2 * scene.cameraScale));
            // Scroll camera center
            ctx.translate(-1 * scene.cameraCenter.x, -1 * scene.cameraCenter.y);

            // Entities
            for (var i = 0; i < scene.entities.length; i++) {
                var entity = scene.entities[i];
                if (entity.hasComponent("Transform")) {
                    var pos = entity.transform.position.copy;
                    if (i == entityToFollow) {
                        lerp(scene.cameraCenter, pos);
                        ctx.beginPath();
                        ctx.strokeStyle = Color.fixedStyle(0, 0, 100, 0.5);
                        ctx.lineWidth = "1";
                        ctx.rect(Math.round(pos.x) - 8, Math.round(pos.y) - 8, 16, 16);
                        ctx.stroke();
                        if (entity.hasComponent("Motion")) {
                            var vel = entity.motion.velocity;
                            ctx.fillStyle = Color.fixedStyle(0, 0, 100, 0.5);
                            ctx.font = Math.round(12 / scene.cameraScale) + "px monospace";
                            ctx.textAlign = "left";
                            ctx.textBaseline = "middle";
                            ctx.fillText("pos: {" + pos.x.toFixed(0) + "," + pos.y.toFixed(0) + "} vel: {" + vel.x.toFixed(2) + "," + vel.y.toFixed(2) + "}", Math.round(pos.x + 15), Math.round(pos.y));
                        }
                    }
                    if (isInViewport(pos)) {
                        ctx.fillStyle = Color.fixedStyle(100, 100, 50, 1);
                        ctx.fillRect(Math.round(pos.x) - 3, Math.round(pos.y) - 3, 6, 6);

                        paths.push({ "pos": pos, "c": Color.fixedStyle(100, 100, 50, 1) });
                        if (paths.length > maxPaths)
                            paths.shift();
                    }
                }
            }

            // Paths
            for (var i = paths.length - 1; i >= 0; i--) {
                if (isInViewport(paths[i].pos)) {
                    ctx.fillStyle = paths[i].c;
                    ctx.fillRect(paths[i].pos.x, paths[i].pos.y, 1, 1);
                } else
                    paths.splice(i, 1);
            }


            ctx.beginPath();
            ctx.strokeStyle = Color.fixedStyle(0, 0, 100, 0.5);
            ctx.lineWidth = "1";
            ctx.rect(0 - Math.round(scene.width / 2), 0 - Math.round(scene.height / 2), scene.width, scene.height);
            ctx.stroke();

            ctx.restore();

            // Followed Entity
            /*
            var entity = scene.entities[entityToFollow];
            if (entity && entity.hasComponent("Motion")) {
                var pos = entity.transform.position.copy;
                var vel = entity.motion.velocity;
                ctx.fillStyle = Color.fixedStyle(0, 0, 100, 0.5);
                ctx.font = "12px monospace";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                ctx.fillText("pos: {" + pos.x.toFixed(0) + "," + pos.y.toFixed(0) + "}", Math.round(canvas.width / 2 + 15), Math.round(canvas.height / 2 - 8));
                ctx.fillText("vel: {" + vel.x.toFixed(2) + "," + vel.y.toFixed(2) + "}", Math.round(canvas.width / 2 + 15), Math.round(canvas.height / 2 + 8));
            }
            */

            // FPS
            ctx.fillStyle = new Color(0, 0, 100, 0.5).style;
            ctx.font = "12px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(Math.round(loop.getFPS()) + " FPS", canvas.width - 55, 35);

            //ctx.fillText(canvas.width + "x" + canvas.height, 50, 35);
            //ctx.fillText(paths.length + " paths", 50, 55);
        }

        function lerp(position, targetPosition) {
            var diff = targetPosition.copy.substract(position.copy);
            position.x += diff.x * 0.1;
            position.y += diff.y * 0.1;
        }

        function isInViewport(point) {
            return true;
            /*
            return point.x > canvas.width / -2
                && point.x < canvas.width / 2
                && point.y > canvas.height / -2
                && point.y < canvas.height / 2;
                */
        }

        var scene = new Scene();
        var loop = new Loop().setUpdate(update).setDraw(draw).start();

        for (var i = 0; i < 50; i++) {
            var entity = new Entity();
            var transform = new TransformComponent();
            transform.position = Vector.Zero;
            entity.addComponent(transform);
            var motion = new MotionComponent();
            motion.velocity = Vector.Zero; //new Vector(Random.float(-0.1, 0.1), Random.float(-0.1, 0.1));
            motion.acceleration = new Vector(Random.float(-0.0001, 0.0001), Random.float(-0.0001, 0.0001));
            motion.maxVelocity = Random.float(0.005, 0.005);
            entity.addComponent(motion);
            scene.entities.push(entity);
        }

    </script>
</body>

</html>